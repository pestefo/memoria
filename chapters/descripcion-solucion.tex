\chapter{Descripción de la Solución}
% +-- TODO --*
% - Mejorar párrafo introductorio (alcance de la solución)
% - Referencias:
%	- Sugiyama Layout
%	- Delta de métrica (referenciar a Juampi)
% - Mostrar un ejemplo dummy en la explicacion 
%   de la visualizacion mostrando codigo e imagenes
% - Figura: 
%	- Visualizacion Clases
% 	- Visualizacion Metodos
% 	- Zoom-in ejecuciones similares, ejecuciones diferentes
% 	- Ventana Workspace con openOn: 'Roassal*' <-- caso real
%	- Ventana de popup



\par A la luz de los resultados del estudio comparativo entre el acercamiento al problema desde la perspectiva del análisis estático y análisis dinámico de  tests presentado en el \chapref{exp-static-vs-dynamic} se concluye que los tests se comparan en función de su ejecución. 

\par Sin embargo, como se mencionó anteriormente, los tests tienen asociada una responsabilidad crítica sobre la calidad del código. En la práctica es el artefacto se software en el cual reside la confianza de que el software hace lo requerido. Por lo cual cualquier refactorización podría alterar el grado de confiabildiad del software.


\section{Comparando la ejecución de tests con \emph{TestSurgeon}}

\par En respuesta a este escenario, se presenta \emph{TestSurgeon}: un profiler para test unitarios. Testsurgeon realiza un monitoreo de la ejecución de test unitarios y recolecta datos sobre \emph{qué} está siendo testeado (cobertura) y \emph{cómo} (contexto). TestSurgeon aproxima la similitud entre métodos de tests a través de una representación visual que relaciona el código testeado y métricas representativas que caracterizan (y diferencian) a los dos test en comparación. 

\par El objetivo de TestSurgeon es apoyar a los ingenieros de software a reestructurar y refactorizar sus tests unitarios a través de un análisis sobre las diferencias de ejecución de los tests.

\subsection{Caso de uso}
\par A modo de resumen, para usar TestSurgeon se siguen las siguientes estapas: Abrir TestSurgeon sobre conjunto de paquetes, Profiling sobre los paquetes seleccionados, escoger tests dos unitarios (no necesariamente distintos), seleccionar dos métodos de test pertenecientes a los unit tests escodigos y finalmente compararlos usando la visualización y el código fuente de estos. En TestSurgeon se realizan comparaciones de métodos de test uno-a-uno por lo cual, para diferenciarlos, se nombran como \emph{test rojo} y \emph{test azul} en concordancia a los colores en la visualización.

\par Para ejemplificar el uso de TestSurgeon se muestra a continuación un ejemplo analizando el software: \emph{Manifest}. Manifest corresponde a una componente de la plataforma Pharo encargada de recolectar metadatos de cada paquete de software con fin de investigar sobre la calidad del software de dichos paquetes.

% Ejemplo Dummy
\par Un análisis con \emph{TestSurgeon} comienza lanzando el software desde una terminal de Pharo o \emph{Workspace} con el siguiente comando: {\tt TSBrowser openOn: 'Manifest-*'}\footnote{Para más detalles sobre este comando y la implementación del browser ver la \secref{impl-browser} }. Este comando es para abrir el browser de TestSurgeon y para analizar todos los paquetes del software Manifest que son nombrados con el prefijo {\tt Manifest-}.


\par Luego, TestSurgeon realiza un profiling sobre los tests encontrados en todos los paquetes de Manifest. Los ejecuta, recolecta los datos y genera los objetos según el modelo de objetos de Spy(ver \secref{impl-spy}). Este proceso puede tardar unos segundos o algunos minutos según la cantidad de tests encontrados y las operaciones propias dentro de cada test.

\par Una vez concluída la etapa de profiling, se desplega una ventana con cuatro zonas principales(ver \figref{caso-uso/2.png}): 
\begin{itemize}
\item {\bf Test Unitarios}: En la zona superior-izquierda aparecen dos listas. Se puede seleccionar solo un unit test por cada lista.
\item {\bf Métodos de Test}: Justo abajo de los test unitarios aparecen dos listas con los métodos de test de los unit tests seleccionados. En cada lista se pueden seleccionar un metodo. El método seleccionado de la izquieda se denomina \emph{test rojo} y el de la derecha \emph{test azul}.
\item {\bf Visualización}: Luego de seleccionados los tests rojo y azul se despliega una visualización que muestra la diferencia en la ejecución de ambos tests.
\item {\bf Código Fuente}: Junto con la visualización se muestra el código fuente de cada test.
\end{itemize}

\fig{h}{0.85}{caso-uso/2.png}{Zonas del browser de TestSurgeon.}

\par Primero se seleccionan los unit test, uno por lista. De los unit test escogidos, hay que seleccionar el test rojo (izquieda). Una vez seleccionado, la lista de métodos de test de la derecha se ordenan verticalmente según similitud de cobertura con el método del test rojo (más similar arriba, más distinto abajo). La métrica de cobertura señalada es la misma que se utilizó en el experimento de similitud estática contra similitud dinámica definida en la \secref{exp1-metricas-sim}. De esta manera se facilitan la búsqueda de casos interesantes a ser comparados. 

\par La cobertura, como métrica, no expresa el cómo los actores (objetos) se comportan (a través de métodos) mientras el test está siendo ejecutado. Por tanto se necesita más datos. Entonces, una vez seleccionado el test azul se puede realizar una mejor comparación observando una visualización que justamente resalta las diferencias en la ejecución de ambos tests.

\par ---------- Falta mostrar los pasos (clic 1 clic 2 y mostrar lo que pasa)
\par ---------- Ventana de popup

\subsection{Visualización: \emph{Test Difference Blueprint}}\seclabel{test-diff-blueprint}

\par El objetivo de la visualización es comparar y encontrar las diferencias de ejecución que existen entre dos métodos de test. Para esto primero se debe hacer una comparación de cobertura, es decir cuáles son los métodos y las clases testeadas por los métodos en comparación. Entonces uno de los elementos a visualizar son las clases y sus métodos. 

\subsubsection{Clases y su jerarquía}

\par En la visualización se muestran todas las clases dentro de la cobertura de al menos uno de los dos test y que pertenezcan a los paquetes instrumentados. Las clases se presentan como grandes rectángulos con fondo blanco y borde negro. Pharo es un lenguaje Orientado a Objetos con Herencia Simple (cada clase puede heredar de una sola clase padre). TestSurgeon, entonces, presenta las clases haciendo gráfica esta estructura agrupándolas con las demás clases de su jerarquía de clases y con una distribución visual en forma de árbol. En esta distribución, la raíz está la en el tope superior de la imagen y en el siguiente nivel del árbol están las clases que heredan directamente de ésta, y así sucesivamente, formando un árbol.

% - Figura: Visualizacion jerarquia de clases

\subsubsection{Coloreando métodos para visualizar cobertura}\seclabel{viz-color}

\par El elemento de análisis principal en el enfoque de TestSurgeon son los métodos de las clases. Los métodos están representados como rectángulos (o cuadrados) de menor tamaño posicionados dentro de la clase que lo define.  Los métodos heredados por la clase no están considerados en la visualización de dicha clase, sino que aparecen en la clase que lo define dentro de la jerarquía
.  

\par Cada método tiene un color asignado:
\begin{itemize}
\item {\bf Rojo}: el método fue llamado únicamente durante la ejecución del test rojo.
\item {\bf Azul}: el método fue llamado únicamente durante la ejecución del test azul.
\item {\bf Gris}: el método fue ejecutado durante la ejecución de ambos tests.
\item {\bf Blanco}: el método fue ejecutado en ninguno de los dos tests.
\end{itemize}

\par Un aspecto importante dentro del análisis de cobertura es conocer los caminos de ejecución según las llamadas a métodos de una clase desde otro método definido en la misma clase. Estas llamadas son invocaciones a {\tt self} (o {\tt this} en Java) que permiten diferenciar si un método fue llamado directamente o a través de una invocación {\tt self} desde otro método que lo invoca. Para graficar esto se utilizó una distribución gráfica de Sugiyama. Más arriba están los métodos que realizan mayores invocaciones a otro métodos definidos en la clase y que no son invocados por otros métodos de la clase. En el tope inferior los métodos que no tienen invocaciones a otros métodos definidos en dicha clase pero sí son invocados por uno o más métodos definidos en la clase.

\par En una distribución de grilla y posicionados a la derecha dentro del rectángulo de la clase, están los que no tienen invocaciones a otros métodos definidos en dicha clase ni son invocados por métodos definidos en esa clase.

\subsubsection{Métricas para caracterizar la ejecución de los métodos }\seclabel{viz-metricas}

\par Hasta ahora, la visualización sólo grafica lo que ha sido ejecutado por uno, otro u ambos tests, es decir, la cobertura. Sin embargo este acercamiento no parece ser tan preciso ni suficiente para tener una idea real de cómo se ejecutaron dichos métodos. Allí es donde emerge la característica más distintiva e innovadora de la visualización de TestSurgeon: incorporar métricas que dan un contexto en el cual un método fue llamado durante la ejecución de los tests en comparación. Así no tan solo se visualiza cuáles fueron los métodos ejecutados por el test rojo o azul (o ambos) y cuales no, sino que además muestra cómo tal método fue ejecutado con el test rojo y cuán diferente fue cuando se ejecutó el método azul.

\par El \emph{Número de Llamadas} a un método ({\tt NOC} - Number of Calls, en inglés) es una de las dos métricas escogidas para esto. Tal como su nombre lo indica, representa la cantidad de veces que un método fue llamado para su ejecución. De esta manera, entre más veces fue llamado, más relevante es para ese test.

\par Por su parte, el \emph{Número de distintos receptores} de un método ({\tt NODR} - Number of Different Receivers, en inglés) indica cuántos objetos distintos ejecutaron dicho método. En un paradigma de programación orientado a objetos, los objetos se comunican a través de mensajes (o métodos). Esta métrica es particularmente útil cuando su {\tt NOC} es parecido ya que su {\tt NODR} puede ser distinto y asi diferencia las ejecuciones del test rojo y azul ofreciendo una perspectiva ortogonal en el análisis.

\par Por ejemplo, supongamos que un cierto método $m_a$ fue ejecutado la misma cantidad de veces durante la ejecución del test rojo y el azul, entonces: {\tt NOC}$(m_a,t_r) = \,${\tt NOC}$(m_a,t_b) = 30$. Y consideremos que {\tt NODR}$(m_a,t_r) = 1$ y {\tt NODR}$(m_a,t_b) = 30$. Durante la ejecución del test rojo, hubo solo una instancia de la clase que define $m_a$ y recibió 30 veces dicho mensaje, un escenario muy distinto al del test azul, donde hubo 30 instancias por lo cual, cada una ejecutó $m_a$ solo una vez.

\par Dado que para un método tenemos 2 métricas por cada test, necesitamos 4 dimensiones para graficarlo: {\tt NOC}$(m_a,t_r)$, {\tt NOC}$(m_a,t_b)$ , {\tt NODR}$(m_a,t_r)$ y {\tt NODR}$(m_a,t_b)$ . Ya que los métodos están gráficamente representados por rectángulos, se decidió que la medida de cada par de lados opuestos será la diferencia entre la métrica para cada test. Entonces, la altura de un rectángulo es la diferencia entre el número de llamados de dicho método durante la ejecución del test rojo y azul. Por su parte, su ancho es la diferencia entre el número de distintos objetos destinatarios del método durante la ejecución del test rojo y azul. 

\par Formalmente:
\[ {\rm altura}(m_a) = \abs{{\tt NOC}(m_a,t_r) - {\tt NOC}(m_a,t_b)} \]
\[ {\rm ancho}(m_a) = \abs{{\tt NODR}(m_a,t_r) - {\tt NODR}(m_a,t_b)} \]

% - Figura: Visualizacion Metodos

\section{Resumen: Interpretando la visualización}


\par La \emph{Test difference execution blueprint} facilita la comprensión de la diferencia de ejecuciones entre dos test methods diferenciandolas sobre lo que efectivamente testearon y contrastando la forma en que lo hicieron. Los colores ayudan a discriminar sobre las diferencias de cobertura, por lo que una alta porción de métodos grises significa que su cobertura es similar, es decir, en su ejecución hay varios métodos en común que se llamaron, lo cual los hace más similares.

\par La forma y tamaño de los métodos en la visualización habla de cómo fueron ejecutados, las métricas que describen esto son: cuantas veces fue llamado(altura) y cuantos objetos distintos ejecutaron dicho método(ancho). Como la visualización se enfoca en diferencias y se están comparando dos tests, el ancho y alto de un método es la diferencia entre dichas métricas para cada ejecución de test y método. Entonces, si un método gris se ve pequeño en tamaño quiere decir que no hubo mucha diferencia entre cuantas veces fue ejecutado por el test rojo y azul, y la cantidad de instancias que ejecutaron ese método en ambos test fue similar. 

\par En el otro caso, si un método gris es grande, quiere decir que ese método es particularmente relevante para uno de los dos tests ya que se ejecuta muchas más veces en uno de los dos casos o es ejecutado por una cantidad mucho mayor de instancias, se presentan ambos casos. 

\par Ahora, considerando los métodos de color rojo o azul, estos se intepretan en una forma ligeramente diferente. Primero es importante considerar su proporción con respecto al total de métodos ejecutados. Si existe gran presencia de métodos rojos y/o azules estamos en un caso de dos tests con cobertura bastante distinta. Por lo tanto, su ejecución se enfoca en características distintas del software. Ahora bien, para casos en que la cobertura es similar (pocos métodos rojos y/o azules), el siguiente aspecto a observar es su forma. Si estos métodos son grandes, quiere decir que son muy relevantes para el tests correspondiente. Porque fue ejecutado muchas veces o bien porque varios objetos de los creados en la ejecución, recibieron ese mensaje.

\par Recapitulando y a grandes rasgos se puede decir que la ejecución de dos test es similar si la visualización presenta una gran cantidad de métodos grises pequeños y en mucho menor grado algunos métodos rojos y/o azules. Por el contrario, dos tests habrán tenido una ejecución muy diferente si se aprecian métodos grandes y con gran presencia de azules y rojos. 

\par A continuación se presenta un resumen de la visualización:

\fig{h}{0.85}{blueprint-summary.pdf}{Test Difference Blueprint}