\chapter{Introducción} 
%% Intro
\par El Testing es una actividad importante en el desarrollo de los proyectos de software en nuestro días. Los tests automatizados ayudan al desarrollador a asegurar la calidad del código y a detectar posibles bugs o defectos en el código de la aplicación. Más aún,los test pueden también ser considerados como  una ``documentación ejecutable'', y ser utilizados también para entender código ajeno.

\par Dado la naturaleza las pruebas de software, su estudio e investigación se ha focalizado en mejorar su efectividad para hacer software cada vez más confiables y robustos. Y al igual que el software funcional, los tests son parte del código fuente de la aplicación. La comunidad de ingeniería de software ha desarrollado diveras técnicas y metodologías para mantener limpio el diseño del código base (o funcional). Sin embargo, poco trabajo se ha realizado para que  el código de los test mantenga una estructura y diseño limpio. Situación que pasa a ser cada vez más problemática a medida que el software crece en tamaño y en complejidad.


%% Terminologia
\section{Terminología}

\par Para la lectura adecuada del documento, se presenta la siguiente terminología con los conceptos principales que se utilizarán a lo largo del documento:

\begin{description}
\item[\emph{test}]: corresponde a un trozo de código que tiene como finalidad simular un comportamiento particular de alguna componente o compontentes del sistema para realizar verificaciones que validen el comportamiento esperado de estas. También se le nombra: \emph{método de test}, \emph{test method} o \emph{prueba de software}.
\item[\emph{unit test}]: corresponde a un grupo de tests que, en conjunto, verifican una funcionalidad en común. También se le nombra: \emph{prueba unitaria} o \emph{grupo de tests}
\item[\emph{smell}]: se refiere a una deficiencia en el diseño del código que da pie a problemas en su mantenibilidad y/o extensibilidad. Cuando existen smells sobre el código se pruebas se nombra como un \emph{test smell}.
\end{description}

%% Motivacion (pq toi haciendo esto?)
\section{Motivación}
% - Contexto: Práctica de Testing, Unit Testing
\par Actualmente el \emph{testing} es una actividad clave dentro del desarrollo de cualquier proyecto de software serio. De hecho las metodologías ágiles de desarrollo consideran la creación de test como el punto de partida de la iteración o ciclo de desarrollo. Ejemplos de estas son el Test-Driven Development (TDD) o Behavior-Driven Development (BDD). El escribir tests que describen la funcionalidad esperada de una unidad de software (TDD) y/o el comportamiento esperado de un conjunto de unidades (BDD) son formas de producir código en el cual se puede confiar, puesto que no se agrega otra funcionalidad sino hasta que existe un test que lo simula y describe el funcionamiento esperado.

\par A medida que el software crece en complejidad y tamaño, de igual manera el código se va volviendo más complejo lo cual atenta contra el crecimiento del proyecto. Para esto, la industria y la academia han desarrollado diversas formas de restructurar y/o refactorizar el código base para enfrentar el \emph{cambio} de la forma menos costosa. Sin embargo esto no ha sido igual para el código que corresponde a los tests. A medida que el sistema evoluciona los tests necesitan también evolucionar para mantenerse actualizado con el sistema~\cite{reichhart2007rule}.  Pero muchas veces esto no sucede, los tests carecen del mismo cuidado que el código base por lo cual muchas veces es necesario reescribir los tests o incluso, no es raro que se deje de escribir tests por el costo en tiempo que esto implica.

\par Por otro lado, la aplicación estricta de estas metodologías ágiles incrementa rápidamente la cantidad de tests. Dentro de los tests escritos existen de bajo y alto nivel. Los de bajo nivel testean las unidades fundamentales del sistema. Las de alto nivel, por su parte, testean la interacción entre estas. Esto refleja una brecha entre las unidades de código testeadas y las pruebas unitarias. La cual es bastante costosa puesto que muchas de los tests de alto nivel suelen repetir código y/o son redundantes en su ejecución. Lo último implica pérdida de tiempo al ejecutar los tests y verificar que el código añadido no rompió alguna parte del sistema.

\par Bajo este escenario, se hace necesaria una forma de reducir esta becha entre el código base y el código de test, y facilitar la detección de \emph{test smells} que significan un gran costo tanto para los desarrolladores como el cliente.



%% Objetivos
\section{Objetivos}
\par El objetivo general de este trabajo es crear una herramienta que permita a los desarrolladores refactorizar y reestructurar sus test de una manera más fácil y mejorar la performance de estos.

\subsection*{Objetivos Específicos}
\begin{itemize}
\item Identificación de las métricas relevantes para caracterización de tests methods desde el punto de vista de un análisis dinámico
\item Desarrollar una visualización que permita detectar redundancia y solapamiento entre grupos de test methods (o unit tests)
\item Investigar refactorizaciones automáticas y semi-automáticas para unit tests y sus implicancias en performance y cobertura
\item Desarrollar una interfaz gráfica efectiva y usable para el uso cotidiano dentro del desarrollo de software
\end{itemize}

%% Organizacion del documento
\section{Estructura del documento}

\par En el \chapref{espec-prob} se presenta el problema de la mantenibilidad de tests en detalle, su contexto y relevancia. Posteriormente se presenta el marco teórico que entrega los conceptos técnicos necesarios (\secref{marco-teorico}), y se entregan una seria de antecedentes que muestra el trabajo realizado tanto por la academia como por la industria en sobre el problema de diseño del código de tests se refiere (\secref{trabajo-relacionado}). 

\par Luego, con la base conceptual y contextual del problema presente, se describe en detalle la solución propuesta: \emph{TestSurgeon}. Primero en forma conceptual en el \chapref{descripcion-solucion} y después en forma técnica en el \chapref{implementacion}. Y después, en el \chaplabel{caso-de-estudio} se muestra una aplicación de la herramienta con una serie de descubrimientos interesantes. 

\par Finalmente en el \chapref{conclusion} se revisa el cumplimiento de los objetivos planteados, las conclusiones del trabajo así como también las posibilidades y algunas directrices para continuarlo.

\par Se adjuntan también algunos anexos interesantes que complementan el documento y entregan datos que por su extensión no pudieron incluídos directamente en los capítulos.
