\chapter{Especificación del Problema}\chaplabel{espec-prob}
% Conceptos para que el lector entienda y pueda leer depsués



\section{Contexto: Test como ``conductores'' del diseño}
\par Durante el desarrollo de un software uno de las actividades principales es el testeo de los requerimientos. Existen variadas técnicas, metodologías y artefactos relacionados a esta actividad. En particular, la creación de pruebas automatizadas es una práctica cotidiana en cualquier proyecto de software y comprende parte importante de los artefactos generados. \\

\par En particular los proyectos de software ágiles dan gran importancia a estos artefactos ya que cada historia de usuario debe tener pruebas de aceptación (tests de alto nivel) que se escriben y detallan con el cliente para asegurar que el código que se creará cumple lo que pide el cliente y ni menos ni más.

\par Estas historias de usuario están escritas en lenguaje natural por lo que se deben \emph{transcribirse} a lenguaje de desarrollo: código fuente. Entonces, antes de escribir una funcionalidad, los desarrolladores crean los tests: código fuente que garantiza que una característica se comporta como es requerida. Este proceso se denomina \emph{Test-Driven Development} (o TDD)~\cite{Beck02a}  o Desarrollo Dirigido por Pruebas: se escribe el test, se ejecuta y este falla (ya que no se ha escrito que suple dicha característica), luego se escribe el código que hace el test funcionar. Se vuelve a ejecutar el test y pasa. Finalmente se refactoriza el código recien escrito para mantener un diseño sustentable y mantenible en el tiempo.

\par Esta práctica está dentro del núcleo de la filosofía que enmarca la agilidad a tal nivel que está prohibido agregar una nueva funcionalidad sin, previamente, haber escrito un test que lo valide~\cite{Beck02a}. Esta queda documentado en el libro de Robert Cecil Martin (más conocido como``Uncle Bob'')~\cite{Mart02b} uno de los escritores del manifiesto ágil~\cite{Fowl01a} quien declara:

\begin{quote}
\emph{``The iteration between writing test cases and code is very rapid [...]. As a result, a very complete body of test cases grows along with the code.''}
\end{quote}


\par En la práctica, aplicando TDD se obtiene una gran cantidad de pruebas unitarias (unit tests) que representan los casos de prueba de la aplicación (Test Cases). Cada Unit Test contiene varios métodos de tests (test methods) que cubren los distintos aspectos a verificar en la funcionalidad que se está testeando.


\section{Problema: ¿Cómo mantener los tests?}

\par La comunidad de ingeniería de software ha producido herramientas efectivas y buenas prácticas para lograr refactorizaciones en el código base que otorguen un buen diseño de código. Sin embargo, en cuanto al código de los tests unitarios no es así. De hecho, estos son raramente modificados y carecen del cuidado que se le da al código base y no se piensa en su modularidad ni extensibilidad. 

% TODO:
% - Mostrar perspectivas de calidad de codigo: Coverage, bleh, bleh (Rule Based Test Quality)
% - Mostrar datos de q el tiempo de ejecucion es costoso

\par Por lo cual no es difícil encontrar deficiencias como \textbf{solapamientos} entre test methods o más general, entre test cases. Estos solapamientos pueden ser de carácter estático: duplicación de código, o bien dinámicos, es decir que dos tests methods tienen ejecuciones similares y por consiguiente testean lo mismo. 
\par Estas deficiencias en el diseño y calidad del código de las pruebas unitarias tiene consecuencias importantes en la calidad del código testeado y en el mismo proceso de desarrollo:
\begin{itemize}
\item \textbf{Performance} Debido a los solapamientos previamente mencionados, muchas veces existe \textbf{ejecución redundante} que va en contra de las características deseables de una suite de tests[\ref{tdd-beck}]. Muchas veces los tests dejan de ejecutarse con la frecuencia deseada.
\item \textbf{Debugging} Otra deficiencia conocida es cuando al correr los tests en presencia de un defecto, éste se queda en evidencia por muchos tests methods, lo cual dificulta la identificación de la causa del bug y su corrección. Coloquialmente se hace más difícil responder la pregunta: \emph{¿Cuál test miro primero?}
\end{itemize}
 
\par De esta manera la confiabilidad en el producto y su calidad se ven impactadas negativamente. 

\par Un caso muy claro del impacto del mal diseño y poco cuidado en los tests sucede en la práctica de \textbf{Integración Contínua} (Continuous Integration)[\ref{contint}]. En esta práctica cada \emph{feature} se implementa tan pronto como es posible, se testea y se pasa a producción de inmediato. De esta manera el equipo de desarrollo realiza varias integraciones por día y el cliente obtiene rápidamente las nuevas funcionalidades a medida que las solicita. \\

\par A modo de ejemplo, la empresa MediaGeniX\footnote{MediaGeniX [en línea] \textless\url{http://www.mediagenix.tv}\textgreater [Consulta: 12/08/2013]} realiza la integración continua desde hace algunos años. Ahí, 30 desarrolladores trabajan sobre el mismo producto y cada uno de ellos construye varias versiones al día. Cada versión que se va a pasar a producción debe pasar su suite de pruebas que comprende alrededor de 30.000 tests. Ellos realizan al menos 3 integraciones diarias en promedio por lo cual recurren a técnicas de paralelización de ejecución de tests para lograrlo. Esto introduce un alto costo económico asociado al los recursos de hardware(servidores, clusters) y además un alto costo en tiempo.\\

\par Esto evidencia la relevancia de mejorar la performance mediante la refactorización y restructuración de los unit tests.
